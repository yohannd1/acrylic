%:title Acrylic parser to-do list

Very meta to have the to-do list in the format itself hehe

Finished %-fold
  (x) Inline LaTeX math support (`${}`)
  (x) HTML - Don't use `<br/>` for line separation. Instead use `<p>` and two classes for the two kinds of line spacing.
  (x) KaTeX - initial setup
  (x) Parse "display math" (the one that's not inline - `$${}`)
  (x) implement `$$:` and `$:` syntax
  (x) Parse header
  (x) Get indent option (default=2, and can be tab if chosen)
  (x) implement inline *bold*, _italic_, _*bold-italic*_ and `code`
  (x) Parse the rest of the document, with `indent` being the indent unit
  (x) Parse error handling (at least error out! for the love of god)
  (x) Turn this into an actual program
  (x) Make `spaced` an attribute of lines (specially because the `:line-latex` rule can also be spaced sometimes!)
  (x) Implement tasks
  (x) HTML - escape sequences + proper output ( get it from https://github.com/yohannd1/yohannd1.github.io )
  (x) Implement `%tags`
  (x) Bug fix - comments followed by multiple @c#{\n}#s inhibits the spacing
  (x) Bug fix (KaTeX) - display math lines need a little bit more space
  (x) Implement folding via `%-fold`
  (x) URL detection
  (x) "Procedural" parsing with Rust (probably faster and... honestly, easier to debug and maintain)
  (x) Bug fix - HTML output is taking dangerously long to generate longer pages
    - This might not be a good thing to focus on for now.
    - Fixed it with the rust rewrite
  (x) bullet points (`*` and `-` at the start of lines)
  (x) Implement `@functions{}`
  (x) Raw arguments -- some examples for code blocks:
    @code##{
    %% syntax one
    @code#{
    this is a basic code block.
    }#

    %% syntax two
    @code{python}#{
    # this code block has an associated language.
    def double(x):
        return x * 2
    assert double(5) == 10
    }#
    }##

( ) Define a list of all builtin functions (kind of a standard)

( ) Think about keyword arguments
  Since I'm going towards a lispy way anyway, I probabvly will just optionally parse an argument as a list of paired stringifiable words.
  So, for example: `@dot{engine @"fpl"}` would be valid

( ) Bug fix - folds eat up the spacing between them and the next element
  - I can think of a quick fix for that, but it'll make things messy (the idea would be to just check whether a `div.spacing` is the last element of the fold and, if it is, just pop it off)

( ) Rethink bold/italic/inline-code
  - I want to make it simple to parse, but still somewhat markdown-like.
  - How to handle escaping characters in these? Maybe just have a function variant that supports them - `@bold`/`@b`, `@inlineCode`/`@ic` and `@italic`/`@i`

( ) Treesitter plugin

( ) Custom functions (use either Lua or Janet - I'd like Janet but I'm not sure how much I can sandbox it)

( ) Think about folds
  - At the moment there's `%-fold` and `@fold`. Neither feel good imo. I'd like to think of something better.

( ) Menu on the top of the page (e.g. "fold all", "unfold all", "print" (which unfolds all, hides the menu and opens the print menu))

( ) Install pipeline (something akin to `make install`)

( ) Cuter CSS

( ) JSON output

( ) KaTeX - automated download script

( ) Optional JS tools for the HTML backend (searching for tags, TODOs and incomplete tasks)

( ) Automated tests (one per parsing stage)
